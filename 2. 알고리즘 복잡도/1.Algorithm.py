"""
  $ 알고리즘 복잡도 계산이 필요한 이유
    - 하나의 문제를 푸는 알고리즘은 다양할 수 있음
    - 따라서 어느 알고리즘이 더 좋은지 분석하기 위해

  $ 알고리즘 복잡도 계산 항목
    - 시간 복잡도 : 알고리즘 실행 속도 ** 좀 더 중요
    - 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈 

  $ 시간 복잡도의 주요 요소
    - 반복문이 지배
 
  $ 표기법
    - Big O (빅-오) 표기법 : O(N)
      : 알고리즘 최악의 실행 시간을 표기
      : 가장 많이/일반적으로 사용
      : 아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미
    - + 오메가 표기법(최상의 실행 시간), 세타 표기법(평균 실행 시간)
"""

# 연습1 : 1부터 n까지의 합을 구하는 알고리즘1
"""
 - 합을 기록할 변수를 만들고 0을 저장
 - n을 1부터 1씩 증가하면서 반복
 - 반복문 안에서 합을 기록할 변수에 1씩 증가된 값을 더함
 - 반복문이 끝나면 합을 출력
"""

# 나의 풀이
number_sum = 0
n = 10
for number in range(1, n + 1):
  number_sum += number

print(number_sum)
print("=========")

# 실제 풀이1  == 시간 복잡도:n, 표기 : O(n)
def sum_all(n):
  total = 0
  for num in range(1, n + 1):
    total += num

  return total

print(sum_all(10))
print("=========")

# 실제 풀이2  == 시간 복잡도:1, 표기 : O(1)
def sum_all2(n):
  return int(n*(n+1)/2)

print(sum_all2(10))
print("=========")

# 풀이2가 좀더 좋은 방법